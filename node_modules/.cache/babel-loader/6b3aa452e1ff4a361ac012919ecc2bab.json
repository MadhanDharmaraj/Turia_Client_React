{"ast":null,"code":"import { createFactory as t, $eq as r, $ne as i, $lt as n, $lte as e, $gt as u, $gte as o, $in as a, $nin as s, $all as f, $size as c, $regex as h, $options as v, $elemMatch as l, $exists as d, eq as b, ne as y, lt as p, lte as w, gt as g, gte as E, within as A, nin as $, all as m, size as j, regex as M, elemMatch as x, exists as F, and as O } from \"@ucast/mongo2js\";\n\nfunction P(t, r) {\n  for (var i = 0; i < r.length; i++) {\n    var n = r[i];\n    n.enumerable = n.enumerable || false;\n    n.configurable = true;\n    if (\"value\" in n) n.writable = true;\n    Object.defineProperty(t, n.key, n);\n  }\n}\n\nfunction R(t, r, i) {\n  if (r) P(t.prototype, r);\n  if (i) P(t, i);\n  return t;\n}\n\nfunction _() {\n  _ = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var i = arguments[r];\n\n      for (var n in i) if (Object.prototype.hasOwnProperty.call(i, n)) t[n] = i[n];\n    }\n\n    return t;\n  };\n\n  return _.apply(this, arguments);\n}\n\nfunction B(t, r) {\n  t.prototype = Object.create(r.prototype);\n  t.prototype.constructor = t;\n  t.__proto__ = r;\n}\n\nfunction T(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nfunction k(t) {\n  return Array.isArray(t) ? t : [t];\n}\n\nvar q = \"__caslSubjectType__\";\n\nfunction z(t, r) {\n  if (r) if (!r.hasOwnProperty(q)) Object.defineProperty(r, q, {\n    value: t\n  });else if (t !== r[q]) throw new Error(\"Trying to cast object to subject type \" + t + \" but previously it was casted to \" + r[q]);\n  return r;\n}\n\nvar C = function t(r) {\n  var i = typeof r;\n  return \"string\" === i || \"function\" === i;\n};\n\nvar S = function t(r) {\n  return r.modelName || r.name;\n};\n\nvar Y = function t(r) {\n  return \"string\" === typeof r ? r : S(r);\n};\n\nfunction L(t) {\n  if (!t) return \"all\";\n  if (t.hasOwnProperty(q)) return t[q];\n  return S(t.constructor);\n}\n\nfunction D(t, r) {\n  var i = k(r);\n  var n = 0;\n\n  while (n < i.length) {\n    var e = i[n++];\n    if (t.hasOwnProperty(e)) i = i.concat(t[e]);\n  }\n\n  return i;\n}\n\nfunction G(t) {\n  if (t.manage) throw new Error('Cannot add alias for \"manage\" action because it is reserved');\n  Object.keys(t).forEach(function (r) {\n    var i = r === t[r] || Array.isArray(t[r]) && (-1 !== t[r].indexOf(r) || -1 !== t[r].indexOf(\"manage\"));\n    if (i) throw new Error(\"Attempt to alias action to itself: \" + r + \" -> \" + t[r]);\n  });\n}\n\nfunction H(t) {\n  if (\"production\" !== process.env.NODE_ENV) G(t);\n  return function (r) {\n    return D(t, r);\n  };\n}\n\nfunction I(t, r, i) {\n  for (var n = i; n < r.length; n++) t.push(r[n]);\n}\n\nfunction J(t, r) {\n  if (!t || !t.length) return r || [];\n  if (!r || !r.length) return t || [];\n  var i = 0;\n  var n = 0;\n  var e = [];\n\n  while (i < t.length && n < r.length) if (t[i].priority < r[n].priority) {\n    e.push(t[i]);\n    i++;\n  } else {\n    e.push(r[n]);\n    n++;\n  }\n\n  I(e, t, i);\n  I(e, r, n);\n  return e;\n}\n\nfunction K(t, r, i) {\n  var n = t.get(r);\n\n  if (!n) {\n    n = i();\n    t.set(r, n);\n  }\n\n  return n;\n}\n\nvar N = function t(r) {\n  return r;\n};\n\nfunction Q(t, r) {\n  if (Array.isArray(t.fields) && !t.fields.length) throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");\n  if (t.fields && !r.fieldMatcher) throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  if (t.conditions && !r.conditionsMatcher) throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n}\n\nvar U = function () {\n  function t(t, r, i) {\n    if (void 0 === i) i = 0;\n    Q(t, r);\n    this.action = r.resolveAction(t.action);\n    this.subject = t.subject;\n    this.inverted = !!t.inverted;\n    this.conditions = t.conditions;\n    this.reason = t.reason;\n    this.fields = t.fields ? k(t.fields) : void 0;\n    this.priority = i;\n    this.t = r;\n  }\n\n  var r = t.prototype;\n\n  r.i = function t() {\n    if (this.conditions && !this.u) this.u = this.t.conditionsMatcher(this.conditions);\n    return this.u;\n  };\n\n  r.matchesConditions = function t(r) {\n    if (!this.conditions) return true;\n    if (!r || C(r)) return !this.inverted;\n    var i = this.i();\n    return i(r);\n  };\n\n  r.matchesField = function t(r) {\n    if (!this.fields) return true;\n    if (!r) return !this.inverted;\n    if (this.fields && !this.o) this.o = this.t.fieldMatcher(this.fields);\n    return this.o(r);\n  };\n\n  R(t, [{\n    key: \"ast\",\n    get: function t() {\n      var r = this.i();\n      return r ? r.ast : void 0;\n    }\n  }]);\n  return t;\n}();\n\nvar V = function t(r, i) {\n  var n = {\n    value: r,\n    prev: i,\n    next: null\n  };\n  if (i) i.next = n;\n  return n;\n};\n\nvar W = function t(r) {\n  if (r.next) r.next.prev = r.prev;\n  if (r.prev) r.prev.next = r.next;\n  r.next = r.prev = null;\n};\n\nvar X = function t() {\n  return {\n    rules: [],\n    merged: false\n  };\n};\n\nvar Z = function t() {\n  return new Map();\n};\n\nvar tt = function t(r, i) {\n  if (!r.h && i.fields) r.h = true;\n};\n\nvar rt = function () {\n  function t(t, r) {\n    if (void 0 === t) t = [];\n    if (void 0 === r) r = {};\n    this.h = false;\n    this.v = new Map();\n    this.l = {\n      conditionsMatcher: r.conditionsMatcher,\n      fieldMatcher: r.fieldMatcher,\n      resolveAction: r.resolveAction || N\n    };\n    this.p = r.detectSubjectType || L;\n    this.g = t;\n    this.A = this.$(t);\n  }\n\n  var r = t.prototype;\n\n  r.detectSubjectType = function t(r) {\n    return C(r) ? r : this.p(r);\n  };\n\n  r.update = function t(r) {\n    var i = {\n      rules: r,\n      ability: this,\n      target: this\n    };\n    this.m(\"update\", i);\n    this.g = r;\n    this.A = this.$(r);\n    this.m(\"updated\", i);\n    return this;\n  };\n\n  r.$ = function t(r) {\n    var i = new Map();\n\n    for (var n = r.length - 1; n >= 0; n--) {\n      var e = r.length - n - 1;\n      var u = new U(r[n], this.l, e);\n      var o = k(u.action);\n      var a = k(u.subject || \"all\");\n      tt(this, u);\n\n      for (var s = 0; s < a.length; s++) {\n        var f = K(i, a[s], Z);\n\n        for (var c = 0; c < o.length; c++) K(f, o[c], X).rules.push(u);\n      }\n    }\n\n    return i;\n  };\n\n  r.possibleRulesFor = function t(r, i) {\n    if (void 0 === i) i = \"all\";\n    if (!C(i)) throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    var n = K(this.A, i, Z);\n    var e = K(n, r, X);\n    if (e.merged) return e.rules;\n    var u = \"manage\" !== r && n.has(\"manage\") ? n.get(\"manage\").rules : void 0;\n    var o = J(e.rules, u);\n    if (\"all\" !== i) o = J(o, this.possibleRulesFor(r, \"all\"));\n    e.rules = o;\n    e.merged = true;\n    return o;\n  };\n\n  r.rulesFor = function t(r, i, n) {\n    var e = this.possibleRulesFor(r, i);\n    if (n && \"string\" !== typeof n) throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");\n    if (!this.h) return e;\n    return e.filter(function (t) {\n      return t.matchesField(n);\n    });\n  };\n\n  r.on = function t(r, i) {\n    var n = this;\n    var e = this.v.get(r) || null;\n    var u = V(i, e);\n    this.v.set(r, u);\n    return function () {\n      if (!u.next && !u.prev && n.v.get(r) === u) n.v.delete(r);else W(u);\n    };\n  };\n\n  r.m = function t(r, i) {\n    var n = this.v.get(r) || null;\n\n    while (null !== n) {\n      var e = n.prev;\n      n.value(i);\n      n = e;\n    }\n  };\n\n  R(t, [{\n    key: \"rules\",\n    get: function t() {\n      return this.g;\n    }\n  }]);\n  return t;\n}();\n\nvar it = function (t) {\n  B(PureAbility, t);\n\n  function PureAbility() {\n    return t.apply(this, arguments) || this;\n  }\n\n  var r = PureAbility.prototype;\n\n  r.can = function t() {\n    var r = this.relevantRuleFor.apply(this, arguments);\n    return !!r && !r.inverted;\n  };\n\n  r.relevantRuleFor = function t(r, i, n) {\n    var e = this.detectSubjectType(i);\n    var u = this.rulesFor(r, e, n);\n\n    for (var o = 0, a = u.length; o < a; o++) if (u[o].matchesConditions(i)) return u[o];\n\n    return null;\n  };\n\n  r.cannot = function t() {\n    return !this.can.apply(this, arguments);\n  };\n\n  return PureAbility;\n}(rt);\n\nvar nt = {\n  $eq: r,\n  $ne: i,\n  $lt: n,\n  $lte: e,\n  $gt: u,\n  $gte: o,\n  $in: a,\n  $nin: s,\n  $all: f,\n  $size: c,\n  $regex: h,\n  $options: v,\n  $elemMatch: l,\n  $exists: d\n};\nvar et = {\n  eq: b,\n  ne: y,\n  lt: p,\n  lte: w,\n  gt: g,\n  gte: E,\n  in: A,\n  nin: $,\n  all: m,\n  size: j,\n  regex: M,\n  elemMatch: x,\n  exists: F,\n  and: O\n};\n\nvar ut = function r(i, n, e) {\n  return t(_({}, nt, i), _({}, et, n), e);\n};\n\nvar ot = t(nt, et);\nvar at = /[-/\\\\^$+?.()|[\\]{}]/g;\nvar st = /\\.?\\*+\\.?/g;\nvar ft = /\\*+/;\nvar ct = /\\./g;\n\nfunction ht(t, r, i) {\n  var n = \"*\" === i[0] || \".\" === t[0] && \".\" === t[t.length - 1] ? \"+\" : \"*\";\n  var e = -1 === t.indexOf(\"**\") ? \"[^.]\" : \".\";\n  var u = t.replace(ct, \"\\\\$&\").replace(ft, e + n);\n  return r + t.length === i.length ? \"(?:\" + u + \")?\" : u;\n}\n\nfunction vt(t, r, i) {\n  if (\".\" === t && (\"*\" === i[r - 1] || \"*\" === i[r + 1])) return t;\n  return \"\\\\\" + t;\n}\n\nfunction lt(t) {\n  var r = t.map(function (t) {\n    return t.replace(at, vt).replace(st, ht);\n  });\n  var i = r.length > 1 ? \"(?:\" + r.join(\"|\") + \")\" : r[0];\n  return new RegExp(\"^\" + i + \"$\");\n}\n\nvar dt = function t(r) {\n  var i;\n  return function (t) {\n    if (\"undefined\" === typeof i) i = r.every(function (t) {\n      return -1 === t.indexOf(\"*\");\n    }) ? null : lt(r);\n    return null === i ? -1 !== r.indexOf(t) : i.test(t);\n  };\n};\n\nvar bt = function (t) {\n  B(Ability, t);\n\n  function Ability(r, i) {\n    if (void 0 === r) r = [];\n    if (void 0 === i) i = {};\n    return t.call(this, r, _({\n      conditionsMatcher: ot,\n      fieldMatcher: dt\n    }, i)) || this;\n  }\n\n  return Ability;\n}(it);\n\nvar yt = function () {\n  function t(t) {\n    this.j = t;\n  }\n\n  var r = t.prototype;\n\n  r.because = function t(r) {\n    this.j.reason = r;\n    return this;\n  };\n\n  return t;\n}();\n\nvar pt = function () {\n  function AbilityBuilder(t) {\n    this.rules = [];\n    this.M = t;\n    this.can = this.can.bind(this);\n    this.cannot = this.cannot.bind(this);\n    this.build = this.build.bind(this);\n  }\n\n  var t = AbilityBuilder.prototype;\n\n  t.can = function t(r, i, n, e) {\n    var u = {\n      action: r\n    };\n\n    if (i) {\n      u.subject = i;\n      if (Array.isArray(n) || \"string\" === typeof n) u.fields = n;else if (\"undefined\" !== typeof n) u.conditions = n;\n      if (\"undefined\" !== typeof e) u.conditions = e;\n    }\n\n    this.rules.push(u);\n    return new yt(u);\n  };\n\n  t.cannot = function t(r, i, n, e) {\n    var u = this.can(r, i, n, e);\n    u.j.inverted = true;\n    return u;\n  };\n\n  t.build = function t(r) {\n    return new this.M(this.rules, r);\n  };\n\n  return AbilityBuilder;\n}();\n\nfunction defineAbility(t, r) {\n  var i = new pt(bt);\n  var n = t(i.can, i.cannot);\n  if (n && \"function\" === typeof n.then) return n.then(function () {\n    return i.build(r);\n  });\n  return i.build(r);\n}\n\nvar wt = function t(r) {\n  return 'Cannot execute \"' + r.action + '\" on \"' + r.subjectType + '\"';\n};\n\nvar gt = function t(r) {\n  this.message = r;\n};\n\ngt.prototype = Object.create(Error.prototype);\n\nvar Et = function (t) {\n  B(ForbiddenError, t);\n\n  ForbiddenError.setDefaultMessage = function t(r) {\n    this.F = \"string\" === typeof r ? function () {\n      return r;\n    } : r;\n  };\n\n  ForbiddenError.from = function t(r) {\n    return new this(r);\n  };\n\n  function ForbiddenError(r) {\n    var i;\n    i = t.call(this, \"\") || this;\n    i.ability = r;\n\n    if (\"function\" === typeof Error.captureStackTrace) {\n      i.name = \"ForbiddenError\";\n      Error.captureStackTrace(T(i), i.constructor);\n    }\n\n    return i;\n  }\n\n  var r = ForbiddenError.prototype;\n\n  r.setMessage = function t(r) {\n    this.message = r;\n    return this;\n  };\n\n  r.throwUnlessCan = function t() {\n    var r;\n    var i = (r = this.ability).relevantRuleFor.apply(r, arguments);\n    if (i && !i.inverted) return;\n    this.action = arguments.length <= 0 ? void 0 : arguments[0];\n    this.subject = arguments.length <= 1 ? void 0 : arguments[1];\n    this.subjectType = Y(this.ability.detectSubjectType(arguments.length <= 1 ? void 0 : arguments[1]));\n    this.field = arguments.length <= 2 ? void 0 : arguments[2];\n    var n = i ? i.reason : \"\";\n    this.message = this.message || n || this.constructor.F(this);\n    throw this;\n  };\n\n  return ForbiddenError;\n}(gt);\n\nEt.F = wt;\nexport { bt as Ability, pt as AbilityBuilder, Et as ForbiddenError, it as PureAbility, ut as buildMongoQueryMatcher, H as createAliasResolver, defineAbility, L as detectSubjectType, dt as fieldPatternMatcher, wt as getDefaultErrorMessage, ot as mongoQueryMatcher, z as subject, k as wrapArray };","map":{"version":3,"sources":["../../src/utils.ts","../../src/Rule.ts","../../src/structures/LinkedItem.ts","../../src/RuleIndex.ts","../../src/PureAbility.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"names":["wrapArray","value","Array","isArray","TYPE_FIELD","setSubjectType","type","object","hasOwnProperty","Object","defineProperty","Error","isSubjectType","getSubjectClassName","modelName","name","getSubjectTypeName","detectSubjectType","subject","constructor","expandActions","aliasMap","rawActions","actions","i","length","action","concat","assertAliasMap","manage","keys","forEach","alias","hasError","indexOf","createAliasResolver","process","env","NODE_ENV","copyArrayTo","dest","target","start","push","mergePrioritized","array","anotherArray","j","merged","priority","getOrDefault","map","key","defaultValue","get","set","identity","x","validate","rule","options","fields","fieldMatcher","conditions","conditionsMatcher","Rule","resolveAction","inverted","reason","undefined","_options","_conditionsMatcher","this","_matchConditions","matches","ast","matchesConditions","matchesField","field","_matchField","linkedItem","prev","item","next","unlinkItem","defaultActionEntry","rules","defaultSubjectEntry","Map","analyze","index","_hasPerFieldRules","RuleIndex","_events","_ruleOptions","_detectSubjectType","_rules","_indexedRules","_buildIndexFor","update","event","ability","_emit","rawRules","indexedRules","subjects","k","subjectRules","possibleRulesFor","subjectType","actionRules","manageRules","has","rulesFor","filter","on","handler","head","_this","delete","payload","current","PureAbility","can","relevantRuleFor","cannot","defaultInstructions","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","$options","$elemMatch","$exists","defaultInterpreters","eq","ne","lt","lte","gt","gte","in","within","nin","all","size","regex","elemMatch","exists","and","buildMongoQueryMatcher","instructions","interpreters","createFactory","mongoQueryMatcher","REGEXP_SPECIAL_CHARS","REGEXP_ANY","REGEXP_STARS","REGEXP_DOT","detectRegexpPattern","match","string","quantifier","matcher","pattern","replace","escapeRegexp","createPattern","patterns","join","RegExp","fieldPatternMatcher","every","f","test","Ability","_PureAbility","RuleBuilder","_rule","because","AbilityBuilder","AbilityType","_AbilityType","bind","build","conditionsOrFields","builder","defineAbility","define","result","then","getDefaultErrorMessage","error","NativeError","NError","message","prototype","create","ForbiddenError","_defaultErrorMessage","setDefaultMessage","messageOrFn","from","captureStackTrace","setMessage","throwUnlessCan"],"mappings":"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","sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject?: Exclude<Subject, SubjectType>): string {\n  if (!subject) {\n    return 'all';\n  }\n\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\nexport function expandActions(aliasMap: AliasesMap, rawActions: string | string[]) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = actions.concat(aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction assertAliasMap(aliasMap: AliasesMap) {\n  if (aliasMap.manage) {\n    throw new Error('Cannot add alias for \"manage\" action because it is reserved');\n  }\n\n  Object.keys(aliasMap).forEach((alias) => {\n    const hasError = alias === aliasMap[alias]\n      || Array.isArray(aliasMap[alias]) && (\n        aliasMap[alias].indexOf(alias) !== -1 || aliasMap[alias].indexOf('manage') !== -1\n      );\n\n    if (hasError) {\n      throw new Error(`Attempt to alias action to itself: ${alias} -> ${aliasMap[alias]}`);\n    }\n  });\n}\n\nexport function createAliasResolver(aliasMap: AliasesMap) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertAliasMap(aliasMap);\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport const linkedItem = <T>(value: T, prev: LinkedItem<T>['prev']) => {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n};\n\nexport const unlinkItem = (item: LinkedItem<any>) => {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n};\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>\n}\n\ndeclare const $abilities: unique symbol;\ndeclare const $conditions: unique symbol;\ninterface WithGenerics {\n  [$abilities]: any\n  [$conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof $abilities],\n  conditions: T[typeof $conditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventHandler<EventsMap<T>[K]>> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update: UpdateEvent<T>\n  updated: UpdateEvent<T>\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst analyze = (index: any, rule: Rule<any, any>) => {\n  if (!index._hasPerFieldRules && rule.fields) {\n    index._hasPerFieldRules = true;\n  }\n};\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<Conditions>;\n  private readonly _detectSubjectType!: Required<RuleIndexOptions<A, Conditions>>['detectSubjectType'];\n  readonly [$abilities]!: A;\n  readonly [$conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    return isSubjectType(object)\n      ? object\n      : this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || 'all');\n      analyze(this, rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[]\n  possibleRulesFor(action: string, subjectType: SubjectType = 'all'): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const manageRules = action !== 'manage' && subjectRules.has('manage')\n      ? subjectRules.get('manage')!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, manageRules);\n\n    if (subjectType !== 'all') {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, 'all'));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventHandler<EventsMap<Public<this>>[T]>\n  ): Unsubscribe {\n    const head = this._events.get(event) || null;\n    const item = linkedItem(handler, head);\n    this._events.set(event, item);\n\n    return () => {\n      if (!item.next && !item.prev && this._events.get(event) === item) {\n        this._events.delete(event);\n      } else {\n        unlinkItem(item);\n      }\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(name: T, payload: EventsMap<this>[T]) {\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T extends {}, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public } from './RuleIndex';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<Ability<any, MongoQuery>> {}\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  AnyObject,\n  AnyClass,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends string\n    ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends { kind: string }\n      ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n      : AnyObject\n    : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: AnyClass<T>;\n\n  constructor(AbilityType: AnyClass<T>) {\n    this._AbilityType = AbilityType;\n    this.can = this.can.bind(this as any);\n    this.cannot = this.cannot.bind(this as any);\n    this.build = this.build.bind(this as any);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return new this._AbilityType(this.rules, options);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder(Ability as unknown as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U) {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(args[1]));\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n"]},"metadata":{},"sourceType":"module"}