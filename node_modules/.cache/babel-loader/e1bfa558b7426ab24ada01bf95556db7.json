{"ast":null,"code":"(function (factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === \"object\") {\n    // Node/CommonJS\n    module.exports = factory();\n  } else {\n    // Browser globals\n    window.wNumb = factory();\n  }\n})(function () {\n  \"use strict\";\n\n  var FormatOptions = [\"decimals\", \"thousand\", \"mark\", \"prefix\", \"suffix\", \"encoder\", \"decoder\", \"negativeBefore\", \"negative\", \"edit\", \"undo\"]; // General\n  // Reverse a string\n\n  function strReverse(a) {\n    return a.split(\"\").reverse().join(\"\");\n  } // Check if a string starts with a specified prefix.\n\n\n  function strStartsWith(input, match) {\n    return input.substring(0, match.length) === match;\n  } // Check is a string ends in a specified suffix.\n\n\n  function strEndsWith(input, match) {\n    return input.slice(-1 * match.length) === match;\n  } // Throw an error if formatting options are incompatible.\n\n\n  function throwEqualError(F, a, b) {\n    if ((F[a] || F[b]) && F[a] === F[b]) {\n      throw new Error(a);\n    }\n  } // Check if a number is finite and not NaN\n\n\n  function isValidNumber(input) {\n    return typeof input === \"number\" && isFinite(input);\n  } // Provide rounding-accurate toFixed method.\n  // Borrowed: http://stackoverflow.com/a/21323330/775265\n\n\n  function toFixed(value, exp) {\n    value = value.toString().split(\"e\");\n    value = Math.round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\n    value = value.toString().split(\"e\");\n    return (+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);\n  } // Formatting\n  // Accept a number as input, output formatted string.\n\n\n  function formatTo(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {\n    var originalInput = input,\n        inputIsNegative,\n        inputPieces,\n        inputBase,\n        inputDecimals = \"\",\n        output = \"\"; // Apply user encoder to the input.\n    // Expected outcome: number.\n\n    if (encoder) {\n      input = encoder(input);\n    } // Stop if no valid number was provided, the number is infinite or NaN.\n\n\n    if (!isValidNumber(input)) {\n      return false;\n    } // Rounding away decimals might cause a value of -0\n    // when using very small ranges. Remove those cases.\n\n\n    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {\n      input = 0;\n    } // Formatting is done on absolute numbers,\n    // decorated by an optional negative symbol.\n\n\n    if (input < 0) {\n      inputIsNegative = true;\n      input = Math.abs(input);\n    } // Reduce the number of decimals to the specified option.\n\n\n    if (decimals !== false) {\n      input = toFixed(input, decimals);\n    } // Transform the number into a string, so it can be split.\n\n\n    input = input.toString(); // Break the number on the decimal separator.\n\n    if (input.indexOf(\".\") !== -1) {\n      inputPieces = input.split(\".\");\n      inputBase = inputPieces[0];\n\n      if (mark) {\n        inputDecimals = mark + inputPieces[1];\n      }\n    } else {\n      // If it isn't split, the entire number will do.\n      inputBase = input;\n    } // Group numbers in sets of three.\n\n\n    if (thousand) {\n      inputBase = strReverse(inputBase).match(/.{1,3}/g);\n      inputBase = strReverse(inputBase.join(strReverse(thousand)));\n    } // If the number is negative, prefix with negation symbol.\n\n\n    if (inputIsNegative && negativeBefore) {\n      output += negativeBefore;\n    } // Prefix the number\n\n\n    if (prefix) {\n      output += prefix;\n    } // Normal negative option comes after the prefix. Defaults to '-'.\n\n\n    if (inputIsNegative && negative) {\n      output += negative;\n    } // Append the actual number.\n\n\n    output += inputBase;\n    output += inputDecimals; // Apply the suffix.\n\n    if (suffix) {\n      output += suffix;\n    } // Run the output through a user-specified post-formatter.\n\n\n    if (edit) {\n      output = edit(output, originalInput);\n    } // All done.\n\n\n    return output;\n  } // Accept a sting as input, output decoded number.\n\n\n  function formatFrom(decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input) {\n    var originalInput = input,\n        inputIsNegative,\n        output = \"\"; // User defined pre-decoder. Result must be a non empty string.\n\n    if (undo) {\n      input = undo(input);\n    } // Test the input. Can't be empty.\n\n\n    if (!input || typeof input !== \"string\") {\n      return false;\n    } // If the string starts with the negativeBefore value: remove it.\n    // Remember is was there, the number is negative.\n\n\n    if (negativeBefore && strStartsWith(input, negativeBefore)) {\n      input = input.replace(negativeBefore, \"\");\n      inputIsNegative = true;\n    } // Repeat the same procedure for the prefix.\n\n\n    if (prefix && strStartsWith(input, prefix)) {\n      input = input.replace(prefix, \"\");\n    } // And again for negative.\n\n\n    if (negative && strStartsWith(input, negative)) {\n      input = input.replace(negative, \"\");\n      inputIsNegative = true;\n    } // Remove the suffix.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice\n\n\n    if (suffix && strEndsWith(input, suffix)) {\n      input = input.slice(0, -1 * suffix.length);\n    } // Remove the thousand grouping.\n\n\n    if (thousand) {\n      input = input.split(thousand).join(\"\");\n    } // Set the decimal separator back to period.\n\n\n    if (mark) {\n      input = input.replace(mark, \".\");\n    } // Prepend the negative symbol.\n\n\n    if (inputIsNegative) {\n      output += \"-\";\n    } // Add the number\n\n\n    output += input; // Trim all non-numeric characters (allow '.' and '-');\n\n    output = output.replace(/[^0-9\\.\\-.]/g, \"\"); // The value contains no parse-able number.\n\n    if (output === \"\") {\n      return false;\n    } // Covert to number.\n\n\n    output = Number(output); // Run the user-specified post-decoder.\n\n    if (decoder) {\n      output = decoder(output);\n    } // Check is the output is valid, otherwise: return false.\n\n\n    if (!isValidNumber(output)) {\n      return false;\n    }\n\n    return output;\n  } // Framework\n  // Validate formatting options\n\n\n  function validate(inputOptions) {\n    var i,\n        optionName,\n        optionValue,\n        filteredOptions = {};\n\n    if (inputOptions[\"suffix\"] === undefined) {\n      inputOptions[\"suffix\"] = inputOptions[\"postfix\"];\n    }\n\n    for (i = 0; i < FormatOptions.length; i += 1) {\n      optionName = FormatOptions[i];\n      optionValue = inputOptions[optionName];\n\n      if (optionValue === undefined) {\n        // Only default if negativeBefore isn't set.\n        if (optionName === \"negative\" && !filteredOptions.negativeBefore) {\n          filteredOptions[optionName] = \"-\"; // Don't set a default for mark when 'thousand' is set.\n        } else if (optionName === \"mark\" && filteredOptions.thousand !== \".\") {\n          filteredOptions[optionName] = \".\";\n        } else {\n          filteredOptions[optionName] = false;\n        } // Floating points in JS are stable up to 7 decimals.\n\n      } else if (optionName === \"decimals\") {\n        if (optionValue >= 0 && optionValue < 8) {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        } // These options, when provided, must be functions.\n\n      } else if (optionName === \"encoder\" || optionName === \"decoder\" || optionName === \"edit\" || optionName === \"undo\") {\n        if (typeof optionValue === \"function\") {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        } // Other options are strings.\n\n      } else {\n        if (typeof optionValue === \"string\") {\n          filteredOptions[optionName] = optionValue;\n        } else {\n          throw new Error(optionName);\n        }\n      }\n    } // Some values can't be extracted from a\n    // string if certain combinations are present.\n\n\n    throwEqualError(filteredOptions, \"mark\", \"thousand\");\n    throwEqualError(filteredOptions, \"prefix\", \"negative\");\n    throwEqualError(filteredOptions, \"prefix\", \"negativeBefore\");\n    return filteredOptions;\n  } // Pass all options as function arguments\n\n\n  function passAll(options, method, input) {\n    var i,\n        args = []; // Add all options in order of FormatOptions\n\n    for (i = 0; i < FormatOptions.length; i += 1) {\n      args.push(options[FormatOptions[i]]);\n    } // Append the input, then call the method, presenting all\n    // options as arguments.\n\n\n    args.push(input);\n    return method.apply(\"\", args);\n  }\n\n  function wNumb(options) {\n    if (!(this instanceof wNumb)) {\n      return new wNumb(options);\n    }\n\n    if (typeof options !== \"object\") {\n      return;\n    }\n\n    options = validate(options); // Call 'formatTo' with proper arguments.\n\n    this.to = function (input) {\n      return passAll(options, formatTo, input);\n    }; // Call 'formatFrom' with proper arguments.\n\n\n    this.from = function (input) {\n      return passAll(options, formatFrom, input);\n    };\n  }\n\n  return wNumb;\n});","map":{"version":3,"names":["factory","define","amd","exports","module","window","wNumb","FormatOptions","strReverse","a","split","reverse","join","strStartsWith","input","match","substring","length","strEndsWith","slice","throwEqualError","F","b","Error","isValidNumber","isFinite","toFixed","value","exp","toString","Math","round","formatTo","decimals","thousand","mark","prefix","suffix","encoder","decoder","negativeBefore","negative","edit","undo","originalInput","inputIsNegative","inputPieces","inputBase","inputDecimals","output","parseFloat","abs","indexOf","formatFrom","replace","Number","validate","inputOptions","i","optionName","optionValue","filteredOptions","undefined","passAll","options","method","args","push","apply","to","from"],"sources":["/var/www/html/Turia_Client_React/node_modules/wnumb/wNumb.js"],"sourcesContent":["(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define([], factory);\r\n  } else if (typeof exports === \"object\") {\r\n    // Node/CommonJS\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals\r\n    window.wNumb = factory();\r\n  }\r\n})(function() {\r\n  \"use strict\";\r\n\r\n  var FormatOptions = [\r\n    \"decimals\",\r\n    \"thousand\",\r\n    \"mark\",\r\n    \"prefix\",\r\n    \"suffix\",\r\n    \"encoder\",\r\n    \"decoder\",\r\n    \"negativeBefore\",\r\n    \"negative\",\r\n    \"edit\",\r\n    \"undo\"\r\n  ];\r\n\r\n  // General\r\n\r\n  // Reverse a string\r\n  function strReverse(a) {\r\n    return a\r\n      .split(\"\")\r\n      .reverse()\r\n      .join(\"\");\r\n  }\r\n\r\n  // Check if a string starts with a specified prefix.\r\n  function strStartsWith(input, match) {\r\n    return input.substring(0, match.length) === match;\r\n  }\r\n\r\n  // Check is a string ends in a specified suffix.\r\n  function strEndsWith(input, match) {\r\n    return input.slice(-1 * match.length) === match;\r\n  }\r\n\r\n  // Throw an error if formatting options are incompatible.\r\n  function throwEqualError(F, a, b) {\r\n    if ((F[a] || F[b]) && F[a] === F[b]) {\r\n      throw new Error(a);\r\n    }\r\n  }\r\n\r\n  // Check if a number is finite and not NaN\r\n  function isValidNumber(input) {\r\n    return typeof input === \"number\" && isFinite(input);\r\n  }\r\n\r\n  // Provide rounding-accurate toFixed method.\r\n  // Borrowed: http://stackoverflow.com/a/21323330/775265\r\n  function toFixed(value, exp) {\r\n    value = value.toString().split(\"e\");\r\n    value = Math.round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\r\n    value = value.toString().split(\"e\");\r\n    return (+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);\r\n  }\r\n\r\n  // Formatting\r\n\r\n  // Accept a number as input, output formatted string.\r\n  function formatTo(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      inputPieces,\r\n      inputBase,\r\n      inputDecimals = \"\",\r\n      output = \"\";\r\n\r\n    // Apply user encoder to the input.\r\n    // Expected outcome: number.\r\n    if (encoder) {\r\n      input = encoder(input);\r\n    }\r\n\r\n    // Stop if no valid number was provided, the number is infinite or NaN.\r\n    if (!isValidNumber(input)) {\r\n      return false;\r\n    }\r\n\r\n    // Rounding away decimals might cause a value of -0\r\n    // when using very small ranges. Remove those cases.\r\n    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {\r\n      input = 0;\r\n    }\r\n\r\n    // Formatting is done on absolute numbers,\r\n    // decorated by an optional negative symbol.\r\n    if (input < 0) {\r\n      inputIsNegative = true;\r\n      input = Math.abs(input);\r\n    }\r\n\r\n    // Reduce the number of decimals to the specified option.\r\n    if (decimals !== false) {\r\n      input = toFixed(input, decimals);\r\n    }\r\n\r\n    // Transform the number into a string, so it can be split.\r\n    input = input.toString();\r\n\r\n    // Break the number on the decimal separator.\r\n    if (input.indexOf(\".\") !== -1) {\r\n      inputPieces = input.split(\".\");\r\n\r\n      inputBase = inputPieces[0];\r\n\r\n      if (mark) {\r\n        inputDecimals = mark + inputPieces[1];\r\n      }\r\n    } else {\r\n      // If it isn't split, the entire number will do.\r\n      inputBase = input;\r\n    }\r\n\r\n    // Group numbers in sets of three.\r\n    if (thousand) {\r\n      inputBase = strReverse(inputBase).match(/.{1,3}/g);\r\n      inputBase = strReverse(inputBase.join(strReverse(thousand)));\r\n    }\r\n\r\n    // If the number is negative, prefix with negation symbol.\r\n    if (inputIsNegative && negativeBefore) {\r\n      output += negativeBefore;\r\n    }\r\n\r\n    // Prefix the number\r\n    if (prefix) {\r\n      output += prefix;\r\n    }\r\n\r\n    // Normal negative option comes after the prefix. Defaults to '-'.\r\n    if (inputIsNegative && negative) {\r\n      output += negative;\r\n    }\r\n\r\n    // Append the actual number.\r\n    output += inputBase;\r\n    output += inputDecimals;\r\n\r\n    // Apply the suffix.\r\n    if (suffix) {\r\n      output += suffix;\r\n    }\r\n\r\n    // Run the output through a user-specified post-formatter.\r\n    if (edit) {\r\n      output = edit(output, originalInput);\r\n    }\r\n\r\n    // All done.\r\n    return output;\r\n  }\r\n\r\n  // Accept a sting as input, output decoded number.\r\n  function formatFrom(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      output = \"\";\r\n\r\n    // User defined pre-decoder. Result must be a non empty string.\r\n    if (undo) {\r\n      input = undo(input);\r\n    }\r\n\r\n    // Test the input. Can't be empty.\r\n    if (!input || typeof input !== \"string\") {\r\n      return false;\r\n    }\r\n\r\n    // If the string starts with the negativeBefore value: remove it.\r\n    // Remember is was there, the number is negative.\r\n    if (negativeBefore && strStartsWith(input, negativeBefore)) {\r\n      input = input.replace(negativeBefore, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Repeat the same procedure for the prefix.\r\n    if (prefix && strStartsWith(input, prefix)) {\r\n      input = input.replace(prefix, \"\");\r\n    }\r\n\r\n    // And again for negative.\r\n    if (negative && strStartsWith(input, negative)) {\r\n      input = input.replace(negative, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Remove the suffix.\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice\r\n    if (suffix && strEndsWith(input, suffix)) {\r\n      input = input.slice(0, -1 * suffix.length);\r\n    }\r\n\r\n    // Remove the thousand grouping.\r\n    if (thousand) {\r\n      input = input.split(thousand).join(\"\");\r\n    }\r\n\r\n    // Set the decimal separator back to period.\r\n    if (mark) {\r\n      input = input.replace(mark, \".\");\r\n    }\r\n\r\n    // Prepend the negative symbol.\r\n    if (inputIsNegative) {\r\n      output += \"-\";\r\n    }\r\n\r\n    // Add the number\r\n    output += input;\r\n\r\n    // Trim all non-numeric characters (allow '.' and '-');\r\n    output = output.replace(/[^0-9\\.\\-.]/g, \"\");\r\n\r\n    // The value contains no parse-able number.\r\n    if (output === \"\") {\r\n      return false;\r\n    }\r\n\r\n    // Covert to number.\r\n    output = Number(output);\r\n\r\n    // Run the user-specified post-decoder.\r\n    if (decoder) {\r\n      output = decoder(output);\r\n    }\r\n\r\n    // Check is the output is valid, otherwise: return false.\r\n    if (!isValidNumber(output)) {\r\n      return false;\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  // Framework\r\n\r\n  // Validate formatting options\r\n  function validate(inputOptions) {\r\n    var i,\r\n      optionName,\r\n      optionValue,\r\n      filteredOptions = {};\r\n\r\n    if (inputOptions[\"suffix\"] === undefined) {\r\n      inputOptions[\"suffix\"] = inputOptions[\"postfix\"];\r\n    }\r\n\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      optionName = FormatOptions[i];\r\n      optionValue = inputOptions[optionName];\r\n\r\n      if (optionValue === undefined) {\r\n        // Only default if negativeBefore isn't set.\r\n        if (optionName === \"negative\" && !filteredOptions.negativeBefore) {\r\n          filteredOptions[optionName] = \"-\";\r\n          // Don't set a default for mark when 'thousand' is set.\r\n        } else if (optionName === \"mark\" && filteredOptions.thousand !== \".\") {\r\n          filteredOptions[optionName] = \".\";\r\n        } else {\r\n          filteredOptions[optionName] = false;\r\n        }\r\n\r\n        // Floating points in JS are stable up to 7 decimals.\r\n      } else if (optionName === \"decimals\") {\r\n        if (optionValue >= 0 && optionValue < 8) {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // These options, when provided, must be functions.\r\n      } else if (\r\n        optionName === \"encoder\" ||\r\n        optionName === \"decoder\" ||\r\n        optionName === \"edit\" ||\r\n        optionName === \"undo\"\r\n      ) {\r\n        if (typeof optionValue === \"function\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // Other options are strings.\r\n      } else {\r\n        if (typeof optionValue === \"string\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Some values can't be extracted from a\r\n    // string if certain combinations are present.\r\n    throwEqualError(filteredOptions, \"mark\", \"thousand\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negative\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negativeBefore\");\r\n\r\n    return filteredOptions;\r\n  }\r\n\r\n  // Pass all options as function arguments\r\n  function passAll(options, method, input) {\r\n    var i,\r\n      args = [];\r\n\r\n    // Add all options in order of FormatOptions\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      args.push(options[FormatOptions[i]]);\r\n    }\r\n\r\n    // Append the input, then call the method, presenting all\r\n    // options as arguments.\r\n    args.push(input);\r\n    return method.apply(\"\", args);\r\n  }\r\n\r\n  function wNumb(options) {\r\n    if (!(this instanceof wNumb)) {\r\n      return new wNumb(options);\r\n    }\r\n\r\n    if (typeof options !== \"object\") {\r\n      return;\r\n    }\r\n\r\n    options = validate(options);\r\n\r\n    // Call 'formatTo' with proper arguments.\r\n    this.to = function(input) {\r\n      return passAll(options, formatTo, input);\r\n    };\r\n\r\n    // Call 'formatFrom' with proper arguments.\r\n    this.from = function(input) {\r\n      return passAll(options, formatFrom, input);\r\n    };\r\n  }\r\n\r\n  return wNumb;\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}